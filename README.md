# PgBouncer Performance Comparison: Direct vs Pooled Connections

This repository provides a complete infrastructure setup to demonstrate the performance benefits of PgBouncer over direct PostgreSQL connections in high-concurrency scenarios.

## üéØ Project Overview

This case study replicates a real-world scenario where we compare PostgreSQL performance with and without PgBouncer under simulated high-concurrency workloads. The setup demonstrates how PgBouncer can:

- **Handle 1000+ concurrent connections** vs PostgreSQL's default 100 connection limit
- **Double throughput** (58 ‚Üí 112 TPS in our tests)
- **Reduce latency by 50%** (340ms ‚Üí 178ms average)
- **Improve reliability** by eliminating connection rejections

## üìä Expected Results

Based on our testing with 20 clients each making 100 short queries:

| Metric | Direct to DB | Via PgBouncer | Improvement |
|--------|--------------|---------------|-------------|
| **Throughput** | ~58 TPS | ~112 TPS | **~2x faster** |
| **Latency** | ~340ms | ~178ms | **50% reduction** |
| **Max Connections** | ~100 | 1000+ | **10x+ capacity** |
| **Connection Errors** | Many | None | **100% reliability** |

## üèóÔ∏è Infrastructure

This setup creates:
- **RDS PostgreSQL** instance (max_connections=100)
- **EC2 instance** running PgBouncer (transaction pooling)
- **EC2 instance** for testing client
- **VPC** with proper networking and security groups

## üöÄ Quick Start

### Prerequisites

1. **AWS Account** with appropriate permissions
2. **Terraform** >= 1.0
3. **AWS CLI** configured with your credentials

### Step 1: Clone and Configure

```bash
git clone <your-repo-url>
cd pgbouncer-performance-test
cp terraform/terraform.tfvars.example terraform/terraform.tfvars
```

### Step 2: Configure Variables

Edit `terraform/terraform.tfvars`:

```hcl
# AWS Configuration
aws_region = "us-west-2"
availability_zone = "us-west-2a"

# Your IP for SSH access (get it from https://whatismyipaddress.com/)
your_ip_address = "YOUR_IP_HERE/32"

# Database Configuration
db_name = "testdb"
db_username = "postgres"
db_password = "your-secure-password-here"

# Instance Configuration
instance_type = "t3.medium"  # Adjust based on your needs
```

### Step 3: Understanding Config Templates

The `config/` directory contains **template files** that show the structure of PgBouncer configuration:

- **`config/pgbouncer.ini`** - PgBouncer configuration template with placeholder values
- **`config/userlist.txt`** - User authentication template with example format

‚ö†Ô∏è **Important**: These are **example files only**! The actual configuration files are automatically generated by Terraform during deployment with real values (RDS endpoints, passwords, etc.).

### Step 4: Deploy Infrastructure

```bash
cd terraform
terraform init
terraform plan
terraform apply
```

### Step 5: Run Performance Tests

```bash
# SSH into the test client (connection details in terraform output)
ssh -i pgbouncer-key.pem ubuntu@<client-ip>

# Run the automated test suite
./run_performance_test.sh
```

## üìÅ Repository Structure

```
pgbouncer-performance-test/
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ config/                        # üìÅ Template configuration files
‚îÇ   ‚îú‚îÄ‚îÄ pgbouncer.ini              # PgBouncer config template
‚îÇ   ‚îî‚îÄ‚îÄ userlist.txt               # User authentication template
‚îú‚îÄ‚îÄ terraform/
‚îÇ   ‚îú‚îÄ‚îÄ main.tf                    # Main infrastructure
‚îÇ   ‚îú‚îÄ‚îÄ variables.tf               # Input variables
‚îÇ   ‚îú‚îÄ‚îÄ outputs.tf                 # Output values
‚îÇ   ‚îú‚îÄ‚îÄ terraform.tfvars.example   # Example configuration
‚îÇ   ‚îî‚îÄ‚îÄ user-data/
‚îÇ       ‚îú‚îÄ‚îÄ pgbouncer-setup.sh     # PgBouncer installation
‚îÇ       ‚îî‚îÄ‚îÄ client-setup.sh        # Test client setup
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ pgbouncer.ini              # PgBouncer configuration
‚îÇ   ‚îî‚îÄ‚îÄ userlist.txt               # Database users
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ run_performance_test.sh    # Main test runner
‚îÇ   ‚îú‚îÄ‚îÄ test_direct_connection.sh  # Direct DB test
‚îÇ   ‚îú‚îÄ‚îÄ test_pgbouncer.sh          # PgBouncer test
‚îÇ   ‚îî‚îÄ‚îÄ analyze_results.py         # Results analysis
‚îî‚îÄ‚îÄ docs/
    ‚îú‚îÄ‚îÄ SETUP.md                   # Detailed setup guide
    ‚îú‚îÄ‚îÄ TROUBLESHOOTING.md         # Common issues
    ‚îî‚îÄ‚îÄ RESULTS_ANALYSIS.md        # Understanding results
```

## üîß Configuration Management

### Template vs Actual Config Files

This project uses a **two-layer configuration approach**:

#### üìÅ **Template Files** (in `config/` - committed to git)
- `config/pgbouncer.ini` - Contains placeholder values like `your-rds-endpoint.amazonaws.com`
- `config/userlist.txt` - Contains example authentication format with dummy hashes
- **Purpose**: Show users the expected configuration structure

#### üñ•Ô∏è **Actual Config Files** (generated on EC2 - NOT in git)
- `/etc/pgbouncer/pgbouncer.ini` - Real RDS endpoint and settings
- `/etc/pgbouncer/userlist.txt` - Real password hashes
- **Generated by**: Terraform user-data scripts during EC2 initialization

### How Config Generation Works

1. **Terraform** reads your `terraform.tfvars` (passwords, endpoints, etc.)
2. **User-data script** runs during EC2 boot
3. **Real config files** are generated with actual values:
   ```bash
   # Example: Real config generation
   DB_HOST="pgbouncer-test-db.cl0isg60s3lb.us-west-2.rds.amazonaws.com"
   MD5_HASH=$(echo -n "${DB_PASSWORD}${DB_USERNAME}" | md5sum)
   echo "\"${DB_USERNAME}\" \"md5${MD5_HASH}\"" > /etc/pgbouncer/userlist.txt
   ```

### Security Benefits
- ‚úÖ **No credentials in git** - Templates contain no real passwords
- ‚úÖ **Dynamic generation** - Fresh configs for each deployment  
- ‚úÖ **Proper permissions** - Config files have restricted access (`640`)

## üß™ Test Scenarios

### Scenario 1: Direct Connection Test
- **Connections**: Attempts 1000 concurrent clients
- **Expected Result**: Fails after ~100 connections
- **Error**: "FATAL: sorry, too many clients already"

### Scenario 2: PgBouncer Test
- **Connections**: 1000 clients ‚Üí PgBouncer ‚Üí ~100 DB connections
- **Expected Result**: All clients served successfully
- **Performance**: 2x throughput, 50% lower latency

### Scenario 3: Connection Overhead Test
- **Test**: 20 clients, 100 queries each, new connection per query
- **Measures**: Pure connection establishment overhead
- **Key Metric**: Time spent connecting vs. querying

## üîß Configuration Details

### PgBouncer Settings
```ini
[databases]
testdb = host=<rds-endpoint> port=5432 dbname=testdb

[pgbouncer]
pool_mode = transaction
max_client_conn = 1000
default_pool_size = 100
reserve_pool_size = 25
```

### PostgreSQL Settings
- `max_connections = 100` (RDS default)
- `shared_buffers = 256MB`
- Instance: `db.t3.micro` (minimal for cost)

## üìà Understanding the Results

The performance improvement comes from:

1. **Connection Reuse**: No handshake overhead for each query
2. **Connection Multiplexing**: 1000 clients share 100 DB connections
3. **Resource Efficiency**: Database focuses on queries, not connection management
4. **Memory Optimization**: Lower memory usage per connection in PgBouncer

## üí∞ Cost Considerations

This test setup runs on minimal AWS resources:
- **RDS db.t3.micro**: ~$13/month (if left running)
- **2x EC2 t3.micro**: ~$17/month (if left running)
- **Total**: ~$30/month if left running

**üí° Remember to destroy resources after testing:**
```bash
terraform destroy
```

## üõ†Ô∏è Customization

### Scaling the Test
- Increase client count in test scripts
- Try different instance sizes
- Test with different PostgreSQL configurations

### Different Pooling Modes
```ini
# Transaction pooling (default - best performance)
pool_mode = transaction

# Session pooling (better compatibility)
pool_mode = session

# Statement pooling (maximum efficiency)
pool_mode = statement
```

## üîç Troubleshooting

### Common Issues
1. **SSH Connection**: Ensure your IP is correctly set in `terraform.tfvars`
2. **RDS Connection**: Check security groups and VPC configuration
3. **PgBouncer Issues**: Check logs with `journalctl -u pgbouncer`

### Debug Commands
```bash
# Check PgBouncer status
sudo systemctl status pgbouncer

# View PgBouncer logs
sudo journalctl -u pgbouncer -f

# Test direct DB connection
psql postgresql://postgres:password@rds-endpoint:5432/testdb

# Check connection pools
psql -p 6432 -U postgres -h localhost -c "SHOW POOLS;"
```

## üìö Additional Resources

- [PgBouncer Documentation](https://www.pgbouncer.org/usage.html)
- [PostgreSQL Connection Limits](https://www.postgresql.org/docs/current/runtime-config-connection.html)
- [pgbench Documentation](https://www.postgresql.org/docs/current/pgbench.html)

## ü§ù Contributing

1. Fork the repository
2. Create a feature branch
3. Test your changes
4. Submit a pull request

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## ‚ö†Ô∏è Disclaimer

This setup is for testing and educational purposes. For production use:
- Use multi-AZ RDS deployment
- Deploy multiple PgBouncer instances with load balancing
- Implement proper monitoring and alerting
- Follow security best practices for production environments 